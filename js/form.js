// Затем проверьте, правильные ли типы стоят у нужных полей, если нет — проставьте правильные.

// 1.1. Загрузка нового изображения:
// Напишите код и добавьте необходимые обработчики для реализации этого пункта техзадания. В работе вы можете опираться на код показа окна с полноразмерной
//  фотографией(ЧТО ИМЕЕТСЯ ВВИДУ ОПИРАТЬСЯ???),

// по клику на иконку c id #upload-file
// вызов метода input или change У ОБРАБОТЧИКА СОБЫТИЙ????
// После выбора изображения (изменения значения поля #upload-file),???????????
// показывается форма редактирования изображения. У элемента .img-upload__overlay удаляется класс hidden, а body задаётся класс modal-open.

// После выбора изображения пользователем с помощью стандартного контрола загрузки файла #upload-file,
//  нужно подставить его в форму редактирования вместо тестового изображения.?????

// ИЗМЕНЕНИЕ МАСШТАБА ИЗОБРАЖЕНИЯ
// обрабочтики событий на элементы с классами scale__control--smaller и scale__control--bigger
// При нажатии на кнопки .scale__control--smaller и .scale__control--bigger должно изменяться значение поля .scale__control--value;
// Значение должно изменяться с шагом в 25. Например, если значение поля установлено в 50%, после нажатия на «+», значение должно стать равным 75%.
//  Максимальное значение — 100%, минимальное — 25%. Значение по умолчанию — 100%;
// При изменении значения поля .scale__control--value изображению внутри .img-upload__preview должен добавляться соответствующий стиль CSS,
//  который с помощью трансформации scale задаёт масштаб. Например, если в поле стоит значение 75%, то в стиле изображения должно быть написано transform: scale(0.75).

//НАЛОЖЕНИЕ ЭФФЕКТА
// В этом задании мы продолжим реализацию сценария загрузки изображения и его редактирования на примере заглушки.

// Напишите код, который позволит пользователю редактировать масштаб изображения.(ПОДКЛЮЧИТЬ СЛАЙДЕР???) Кроме визуального применения эффекта необходимо записывать значение
// в поле формы с масштабом, доступное только для чтения(?????), для дальнейшей отправки на сервер.(ЗАПИСЬ В МАССИВ???)
// С помощью библиотеки noUiSlider (/vendor/nouislider) реализуйте применение эффекта для изображения.
// Кроме визуального применения эффекта необходимо записывать значение в скрытое поле для дальнейшей отправки на сервер.(?????)

// Обратите внимание, что при переключении фильтра, уровень эффекта должен сразу сбрасываться до начального состояния,
//  т. е. логика по определению уровня насыщенности должна срабатывать не только при «перемещении» слайдера,
// но и при переключении фильтров.
// применение одного из заранее заготовленных эффектов(КАК ДОЛЖНА ВЫГЛЯДЕТЬ ЛОГИКА И ИНСТРУМЕНТЫ ЕЕ РЕАЛИЗАЦИИ)
// выбор глубины эффекта с помощью ползунка (СЛАЙДЕР????)
// добавление текстового комментария (ЛОГИКА И ИСТРУМЕНТЫ, КАКОЙ КОММЕНТАРИЙ ИМЕЕТСЯ ВВИДУ???)
// По умолчанию должен быть выбран эффект «Оригинал».(????????)
// На изображение может накладываться только один эффект.(????????)
// При смене эффекта, выбором одного из значений среди радиокнопок .effects__radio,
// добавить картинке внутри .img-upload__preview CSS-класс, соответствующий эффекту.(КЛАССЛИСТ??????)
//  Например, если выбран эффект .effect-chrome, изображению нужно добавить класс effects__preview--chrome.(ШАБЛОНЫ?????)
// Интенсивность эффекта регулируется перемещением ползунка в слайдере.
// Слайдер реализуется сторонней библиотекой для реализации слайдеров noUiSlider.
// Уровень эффекта записывается в поле .effect-level__value. При изменении уровня интенсивности эффекта (предоставляется API слайдера),(????)
// CSS-стили картинки внутри .img-upload__preview обновляются следующим образом:(КАК ЭТО СВЯЗАТЬ????)
// Для эффекта «Хром» — filter: grayscale(0..1) с шагом 0.1;
// Для эффекта «Сепия» — filter: sepia(0..1) с шагом 0.1;
// Для эффекта «Марвин» — filter: invert(0..100%) с шагом 1%;
// Для эффекта «Фобос» — filter: blur(0..3px) с шагом 0.1px;
// Для эффекта «Зной» — filter: brightness(1..3) с шагом 0.1;
// Для эффекта «Оригинал» CSS-стили filter удаляются.(РЕАЛИЗАЦИЯ????)
// При выборе эффекта «Оригинал» слайдер и его контейнер (элемент .img-upload__effect-level) скрываются.(КЛАССЛИСТ???)
// При переключении эффектов, уровень насыщенности сбрасывается до начального значения (100%): слайдер,
// CSS-стиль изображения и значение поля должны обновляться.(РЕАЛИЗАЦИЯ????)
// ЗАКРЫТИЕ ФОРМЫ РЕДАКТИРОВАНИЯ ИЗОБРАЖЕНИЯ производится либо нажатием на кнопку #upload-cancel, либо нажатием клавиши Esc.(ОБРАБОТЧИКИ СОБЫТИЙ НА КНОПКУ???)
// ,(ОБРАБОТЧИК СОБЫТИЙ НА ESC???)
//  Элементу .img-upload__overlay возвращается класс hidden. У элемента body удаляется класс modal-open.(КЛАССЛИСТЫ????)
// Обратите внимание, что при закрытии формы дополнительно необходимо сбрасывать значение поля выбора файла #upload-file. (РЕАЛИЗАЦИЯ????)
// В принципе, всё будет работать,если при повторной попытке загрузить в поле другую фотографию.
// Но! Событие change не сработает, если пользователь попробует загрузить ту же фотографию,
// а значит окно с формой не отобразится, что будет нарушением техзадания. Значение других полей формы также нужно сбрасывать.(И ЧТО С ЭТИМ СДЕЛАТЬ????)
// Напишите код для валидации формы добавления изображения, используя библиотеку Pristine (/vendor/pristine). Список полей для валидации:

// ДОБАВЛЕНИЕ ХЭШТЭГОВ
// НАПИСАТЬ РЕГУЛЯРНОЕ ВЫРАЖЕНИЕ ВАЛИДИРУЮЩЕЕ ИНПУТ ДЛЯ ХЭШТЭГОВ
// хэш-тег начинается с символа # (решётка);
// строка после решётки должна состоять из букв и чисел и не может содержать пробелы, спецсимволы (#, @, $ и т. п.), символы пунктуации
// (тире, дефис, запятая и т. п.), эмодзи и т. д.;
// хеш-тег не может состоять только из одной решётки;
// максимальная длина одного хэш-тега 20 символов, включая решётку;(МАКСЛЕС ИЛИ ПРИСТИН????)
// хэш-теги нечувствительны к регистру: #ХэшТег и #хэштег считаются одним и тем же тегом;(LOWERcASE????)
// хэш-теги разделяются пробелами;(????????)
// один и тот же хэш-тег не может быть использован дважды;(ПРОВЕРКА МАССИВА НА СОДЕРЖИМОЕ???)
// Для валидации хэш-тегов вам придётся вспомнить, как работать с массивами. Набор хэш-тегов можно превратить в массив, воспользовавшись методом .split().
//  Он разбивает строки на массивы. После этого, вы можете написать цикл, который будет ходить по полученному массиву и проверять каждый из хэш-тегов на
//  предмет соответствия ограничениям.
// Если хотя бы один из тегов не проходит нужных проверок, показывать сообщение об ошибке.(IF????)
// нельзя указать больше пяти хэш-тегов;(МАКСЛЕНС В РАЗМЕТКЕ ИЛИ ВАЛИДАЦИЯ В ПРИСТИН?????)
// хэш-теги необязательны;;(ПРОСТО ОТСУТСТВУЕТ АТРИБУТ REQUIRED????)
// если фокус находится в поле ввода хэш-тега, нажатие на Esc не должно приводить к закрытию формы редактирования изображения.(ОТМЕНА СЦЕНАРИЯ БРАУЗЕРА????)
// Как отменить обработчик Esc при фокусе?
// Задача не имеет одного верного решения, однако намекнём на самый простой — использовать stopPropagation для события нажатия клавиш в поле при фокусе.

//КОММЕНТАРИЙ

// комментарий не обязателен;(ПРОСТО ОТСУТСТВУЕТ АТРИБУТ REQUIRED????)
// длина комментария не может составлять больше 140 символов;(МАКСЛЕНС В РАЗМЕТКЕ ИЛИ НАСТРОЙКИ ПРИСТИН)
// если фокус находится в поле ввода комментария, нажатие на Esc не должно приводить к закрытию формы редактирования изображения.(ОТМЕНА СЦЕНАРИЯ БРАУЗЕРА????)
// Как отменить обработчик Esc при фокусе?
// Задача не имеет одного верного решения, однако намекнём на самый простой — использовать stopPropagation для события нажатия клавиш в поле при фокусе.(IF????)
// Реализуйте логику проверки так, чтобы, как минимум, она срабатывала при попытке отправить форму и не давала этого сделать,
// если форма заполнена не по правилам.(ПРИСТИН?????)
//  При желании, реализуйте проверки сразу при вводе значения в поле.(ШТОАА?)
